<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Lanyon</title>
 <link href="http://lanyon.getpoole.com/atom.xml" rel="self"/>
 <link href="http://lanyon.getpoole.com/"/>
 <updated>2016-09-13T23:54:21-04:00</updated>
 <id>http://lanyon.getpoole.com</id>
 <author>
   <name>Mark Otto</name>
   <email>markdotto@gmail.com</email>
 </author>

 
 <entry>
   <title>RailsJS jQuery Front End - Handlebars</title>
   <link href="http://lanyon.getpoole.com/2016/09/13/railsjs-jquery-front-end/"/>
   <updated>2016-09-13T00:00:00-04:00</updated>
   <id>http://lanyon.getpoole.com/2016/09/13/railsjs-jquery-front-end</id>
   <content type="html">&lt;p&gt;It’s been a while since my last blog post but I’m back at it again with another new app! This time I built a Pinterest style app utilizing javascript/jQuery and HandlebarsJS to handle the front end while Rails took care of the back end. If you’re unfamiliar with Handlebars I recommend you take a quick look at the &lt;a href=&quot;http://handlebarsjs.com/&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt; before proceeding.&lt;/p&gt;

&lt;p&gt;A high level overview of how Handlebars works is that it basically gives us templates that we insert into our HTML pages that we want to use our API with. Then we can use javascript to call and insert objects from the database directly into the DOM without a page refresh. Lets start by taking a look at our template in our HTML:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss12.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see here that this looks almost like an ERB file. In fact, this is basically ERB for javascript. Since we are still in an actual ERB file we can still use ruby &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;%= current_user.name %&amp;gt;&lt;/code&gt; and javascript &lt;code class=&quot;highlighter-rouge&quot;&gt;[[content]]&lt;/code&gt;* at the same time. Pretty cool.&lt;/p&gt;

&lt;p&gt;*&lt;i&gt;Markdown doesnt like the curly braces so we have to use brackets&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Next lets create a constructor in javascript.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss11.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here our Comment belongs_to a user and has the attributes id, content, and user_id. After we set this up, next we need to build a function on this prototype that will return the HTML for the page we have our script in.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss13.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You’re probably wondering what the &lt;code class=&quot;highlighter-rouge&quot;&gt;.template&lt;/code&gt; method is on our Comment. First, we need to grab the template (an HTML string). Then, if you recall from the documentation we need to &lt;em&gt;compile&lt;/em&gt; our HTML string into an actual handlebars template.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss14.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What this now allows us to do is inject our object’s properties using that mustache syntax into our DOM via our compiled template!&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>RESTful Rails Blog with OAuth</title>
   <link href="http://lanyon.getpoole.com/2016/07/02/restful-rails-blog-with-oauth/"/>
   <updated>2016-07-02T00:00:00-04:00</updated>
   <id>http://lanyon.getpoole.com/2016/07/02/restful-rails-blog-with-oauth</id>
   <content type="html">&lt;p&gt;I decided to build a fully functional blog application from the ground up for my Rails assessment project at Flatiron School. It was the biggest challenge I’ve faced since starting my journey into programming. I feel like I have come so far in the world of programming, yet at the same time barely scratching the surface. That is awesome. Steep learning curves excite me.&lt;/p&gt;

&lt;p&gt;One of the most challenging sprints of this project was building out the comments system. My User model looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss6.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Post model:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss8.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and my comment model acting as a join:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss7.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;My problem was that I needed to be able to add a comment - from a user - to a particular post. I spent a lot of time trying to create a comment through the posts controller until I realized that even though my comments model was a join table, I still needed to build the comments controller to separate concerns. Even though a comment belongs to a post, a post controller should not have the responsibility of creating a comment. A comment is still a valid object in my program that deserves attention just as much as a User or Post.&lt;/p&gt;

&lt;p&gt;Here’s how my comments controller turned out:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss9.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;My next challenging sprint was the implementation of Oauth using facebook as a provider. &lt;a href=&quot;https://github.com/plataformatec/devise/wiki/OmniAuth:-Overview&quot;&gt;This guide&lt;/a&gt; is an excellent step by step walkthrough on how to implement Oauth via facebook. One important thing to note about this was that I had trouble with my APP ID consumer key and secret key. A bug prevented me from being able to set my keys through my environment, so I had to add both keys to my project. It is extremely important that these keys, especially the secret key, is not in public view, ie. in the git source code.&lt;/p&gt;

&lt;p&gt;To take care of this problem I added a file in my &lt;code&gt;config/initializers&lt;/code&gt; folder that contained both keys as constants, then added that file to my .gitignore file so it would not get uploaded as public source code on github. I realize that this may not be an optimal solution as all code is still uploaded to a server.&lt;/p&gt;

&lt;p&gt;My last sprint that I wanted to discuss was building a REST infrastructure. A design decision I made early on was to rename the &lt;code&gt;PostsController&lt;/code&gt; to &lt;code&gt;InjuriesController&lt;/code&gt; because I wanted my routes to be &lt;code&gt;/injuries&lt;/code&gt;, &lt;code&gt;/injuries/new&lt;/code&gt; etc.. but quickly realized that that design decision may be confusing as the app gets larger. I’ve learned that it is usually better to err on the side of convention when it comes to Rails development. So instead, I kept &lt;code&gt;PostsController&lt;/code&gt; and passed an option to &lt;code&gt;resources&lt;/code&gt; in my routes file:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ss10.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;i&gt;I had an awesome time and learned so much while building this app. If you like what you read you can check out my previous posts listed in my &lt;a href=&quot;https://jamesnvk.github.io/archives/&quot;&gt;archive&lt;/a&gt;. Or you can check out the full source code for this project on github &lt;a href=&quot;https://github.com/jamesnvk/injury-door&quot;&gt;here&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Why software?</title>
   <link href="http://lanyon.getpoole.com/2016/06/04/why-software/"/>
   <updated>2016-06-04T00:00:00-04:00</updated>
   <id>http://lanyon.getpoole.com/2016/06/04/why-software</id>
   <content type="html">&lt;p&gt;I’ve put in over 600 hours since I started to learn how to code back in November when I got accepted into Flatiron School. I have to say that after I put in that amount of time I still feel like I am just scratching the surface. That’s not necessarily a bad thing, though, as things that are generally worth achieving almost always seem to have a steep learning curve. Pro athletes, pilots, musicians, physicians and actors all have one thing in common – they practice. Then they practice more. And more. And more. Until one day they find that the skill they are practicing on a consistent basis becomes a habit, which then becomes valuable enough to the world that people are willing to pay them lots of money. They become a professional.&lt;/p&gt;

&lt;p&gt;So… why software? It’s the money… right? Software engineers make an above average living working in such a high demand field. If this was about the money I would have quit a long time ago. Flatiron School’s online curriculum is self-paced, which means the only person that will motivate you to keep pushing through those late nights coming home after work - staring into the abyss of failing tests - is yourself.&lt;/p&gt;

&lt;p&gt;I’m willing to bet most people who were at the mastery level of their game aren’t going to look back at their life and say “I made $X amount of dollars during that year!” when asked the question “What did you enjoy most about your career?”&lt;/p&gt;

&lt;p&gt;I’m not saying that setting goals for yourself to earn a great living is a bad thing. What I am saying is this: the process of mastering a craft itself is something that money can’t buy.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sinatra ActiveRecord MVC Application</title>
   <link href="http://lanyon.getpoole.com/2016/03/27/sinatra-ar-mvc-app/"/>
   <updated>2016-03-27T00:00:00-04:00</updated>
   <id>http://lanyon.getpoole.com/2016/03/27/sinatra-ar-mvc-app</id>
   <content type="html">&lt;p&gt;I’ve learned a ton since I built my first CLI gem in my last project. Flatiron School’s Full Stack Dev curriculum really knows how to keep us just on the edge of our knowledge - Always challenging and I’m absolutely addicted. This project’s requirements are as follows:&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;REQUIREMENTS&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Build an MVC Sinatra Application.&lt;/li&gt;
  &lt;li&gt;Use ActiveRecord with Sinatra.&lt;/li&gt;
  &lt;li&gt;Use Multiple Models.&lt;/li&gt;
  &lt;li&gt;Use at least one has_many relationship&lt;/li&gt;
  &lt;li&gt;Must have user accounts. The user that created the content should be the only person who can modify that content&lt;/li&gt;
  &lt;li&gt;Models must have validations to ensure that bad data isn’t created&lt;/li&gt;
  &lt;li&gt;Any validation failures must be shown to user with an error message&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I decided I wanted to build a game collection app that keeps track of a users games. When I was younger (the days before Steam was a thing) I had a ton of games on PC/DVD, SNES, N64 and no where to keep track of them! My first task is to determine file structure, more importantly.. which gems I will be needing to create this app. &lt;img src=&quot;/assets/ss1.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next let’s build out the models. A User &lt;code&gt;has many&lt;/code&gt; games and a Game &lt;code&gt;belongs to&lt;/code&gt; a user. We’re being taught that starting out with the models first is a great pattern for building web apps from scratch. This way we can directly interact with our data first before committing to building out the larger portion of the framework like the controllers and routing. We can always come back to add attributes or functionality to the models in the future as well.&lt;/p&gt;

&lt;p&gt;Now let’s setup our database. We have to create 2 tables, one for users and one for games. We’re going to run &lt;code&gt;rake db:create_migration NAME=create_users&lt;/code&gt; and do the same for games. Our code in our migration file will look like this: &lt;img src=&quot;/assets/ss2.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We’re creating 3 columns for our 3 attributes: Games have a name, year, and a foreign key: &lt;code&gt;user_id&lt;/code&gt; since games &lt;code&gt;belong_to&lt;/code&gt; a User. We’ll do the same for Users then run &lt;code&gt;rake db:migrate&lt;/code&gt; to execute the changes. After our tables are setup we’ll need to add our 2 models to our app. &lt;img src=&quot;/assets/ss3.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With our tables and models setup and migrated our Users and Games are now associated. Remember that the model that has belongs_to will always have the foreign key. In this case, our Game model has the foreign key &lt;code&gt;user_id&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let’s start with the User class. We’re &lt;code&gt;include&lt;/code&gt;ing instance method &lt;code&gt;slug&lt;/code&gt; that will take a user’s username, downcase it, and replace all spaces with dashes. That’s the beauty of ruby.. we can just look at the method and know exactly what it does. The purpose of this method is to have our URLs remain RESTful. Next we’re &lt;code&gt;extend&lt;/code&gt;ing our class method &lt;code&gt;find_by_slug&lt;/code&gt; that will give us the ability to find a user by their slugified name.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;has_secure_password&lt;/code&gt; is a macro given to us by ActiveRecord. However in order to use this we will need to have &lt;code&gt;sessions&lt;/code&gt; enabled and also our gem &lt;code&gt;bcrypt&lt;/code&gt; that we installed earlier. &lt;code&gt;Bcrypt&lt;/code&gt; gives us the ability to store a salted and hashed version of a user’s password in a database column called &lt;code&gt;password_digest&lt;/code&gt;. Let’s add that now.  &lt;img src=&quot;/assets/ss4.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To wrap up user auth we are given a method &lt;code&gt;authenticate&lt;/code&gt; that is provided to us by the Bcrypt gem, which takes a string as an argument. If the string password matches the string password in the password digest, it will return the user object, otherwise it will return false. &lt;img src=&quot;/assets/ss5.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We ensure that bad data isn’t being passed with our helper methods &lt;code&gt;logged_in?&lt;/code&gt; which evaluates the truthiness of a session[:id] and &lt;code&gt;empty_field?&lt;/code&gt; which ensures that a user fills out all form fields when logging in or signing up. Since the our session hash persists across our URLs, it is a very useful tool allowing a web app to persist a user across the entire scope of the application. In other words, the user does not have to log in every time they request a new page. This introduces “state” in an otherwise stateless web. Check out all of my controller routes and actions on my full &lt;a href=&quot;https://github.com/jamesnvk/game-collection-sinatra-app&quot;&gt;github repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For our last requirement I decided to use the flash gem found &lt;a href=&quot;https://github.com/SFEley/sinatra-flash&quot;&gt;here&lt;/a&gt;. This cool little gem adds an error message for the user when they fail a validation.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I learned a ton about how the web operates doing this project. It was a lot of work and I’m glad that I’m learning a basically smaller version of Rails before moving onto the behemoth. Feel free to send me an email jamesnovak90@gmail.com I’d love to hear from you!&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Building a CLI Gem</title>
   <link href="http://lanyon.getpoole.com/2016/01/27/jamesnovak-cli-gem/"/>
   <updated>2016-01-27T00:00:00-05:00</updated>
   <id>http://lanyon.getpoole.com/2016/01/27/jamesnovak-cli-gem</id>
   <content type="html">&lt;div class=&quot;message&quot;&gt;
  My first Ruby CLI Gem: Train Hard
&lt;/div&gt;

&lt;p&gt;My idea for this gem is fairly straightforward. It is a command line interface that scrapes from a website that lists exercises by muscle groups. Each muscle has many exercises. Each exercise belongs to a muscle.&lt;/p&gt;

&lt;p&gt;The first order of business is to bust out the notepad and organize the project into small bite sized pieces. Here’s what I got (shoutout to Avi ;))&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Plan your gem, imagine your interface&lt;/li&gt;
  &lt;li&gt;Start with the project structure - google&lt;/li&gt;
  &lt;li&gt;Start with the entry point  - the file run&lt;/li&gt;
  &lt;li&gt;Stub out the interface&lt;/li&gt;
  &lt;li&gt;Start making things real. Discover objects. PROGRAM.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Alright! Lets get started shall we?&lt;/p&gt;

&lt;h2 id=&quot;plan-your-gem-imagine-your-interface&quot;&gt;1. Plan your gem, imagine your interface&lt;/h2&gt;

&lt;p&gt;A CLI seems like a fairly simple idea. The program asks a user a question, and the user responds to the question with the correct input. So when we first run our gem we want to ask our user an important question (one which they want to be asked since they installed the gem, and one that is concise and to the point.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Which muscle group are you training today?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Using &lt;code&gt;gets.strip&lt;/code&gt; we can determine by number, which muscle group a user wants to see exercises for, then display that list to the user. We will of course list those muscle groups by number.&lt;/p&gt;

&lt;h2 id=&quot;start-with-the-project-structure&quot;&gt;2. Start with the project structure&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bundle gem train_hard&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Magic! We now have a brand new directory with all of our necessary files to create a gem.&lt;/p&gt;

&lt;h2 id=&quot;start-with-the-entry-point&quot;&gt;3. Start with the entry point&lt;/h2&gt;

&lt;p&gt;In our &lt;code&gt;bin&lt;/code&gt; directory is where we want to encapsulate all of our code into a simple call to execute our program. It seems to be best practice not to place logic in this directory. I added &lt;code&gt;#!/usr/bin/env ruby&lt;/code&gt; to tell the interpreter that this is a ruby file. I also added &lt;code&gt;require &#39;./lib/train_hard&#39;&lt;/code&gt; since we will be needing our &lt;code&gt;cli.rb&lt;/code&gt; class to run the file.&lt;/p&gt;

&lt;p&gt;In our &lt;code&gt;lib&lt;/code&gt; directory is where the meat of the program lies. We have a file called &lt;code&gt;train_hard.rb&lt;/code&gt; that is responsible for loading all the required files including our &lt;code&gt;nokogiri&lt;/code&gt; gem and &lt;code&gt;open-uri&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;stub-out-the-interface&quot;&gt;4. Stub out the interface&lt;/h2&gt;

&lt;p&gt;Our program should start just by running &lt;code&gt;./bin/train_hard&lt;/code&gt; command. Inside our bin/train_hard file we should only have code that looks like this to encapsulate our logic and run our program&lt;/p&gt;
&lt;div class=&quot;message&quot;&gt;
#!/usr/bin/env ruby&lt;br /&gt;

require &quot;bundler/setup&quot;&lt;br /&gt;
require &quot;train_hard&quot;&lt;br /&gt;

TrainHard::CLI.new.start
&lt;/div&gt;

&lt;p&gt;Our first method that is going to be run in our CLI is our &lt;code&gt;display_menu&lt;/code&gt; method which displays a menu for the user to choose which muscle group they would like exercises for. For now, we are going to hard-code our method just to be able to have a visualization of what the program will look like before it becomes real. For example
&lt;code&gt;puts &quot;Which muscle group are you training today? (enter number):&quot;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;
def display_menu&lt;br /&gt;
  puts &quot;Which muscle group are you training today?:&quot;&lt;br /&gt;
  puts &amp;lt;&amp;lt;-DOC&lt;br /&gt;
  1. Chest&lt;br /&gt;
  2. Back&lt;br /&gt;
  3. Legs&lt;br /&gt;
  4. Shoulders&lt;br /&gt;
  5. Abs&lt;br /&gt;
  6. Arms&lt;br /&gt;
    DOC&lt;br /&gt;
   end
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let’s do the same for our &lt;code&gt;pick&lt;/code&gt; method, which will &lt;code&gt;gets&lt;/code&gt; from a user to enter the number which they would like to train, then based on that number display that muscle’s exercises. Example:&lt;br /&gt;
&lt;code&gt;
  def pick&lt;br /&gt;
    input = nil&lt;br /&gt;
    while input != &quot;exit&quot;&lt;br /&gt;
    puts &quot;Enter number of the muscle you would like to train or type menu to display menu:&quot; &lt;br /&gt;
    input = gets.strip &lt;br /&gt;
      case input &lt;br /&gt;
      when &quot;1&quot; &lt;br /&gt;
      puts &quot;Exercises for 1&quot; &lt;br /&gt;
      etc...
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now that we have our code stubbed lets start actually programming!&lt;/p&gt;

&lt;h2 id=&quot;start-making-things-real-discover-objects-program&quot;&gt;5. Start making things real. Discover objects. PROGRAM&lt;/h2&gt;

&lt;p&gt;The fun part! The first thing we have to do is figure out what exactly a “muscle” consists of, and what our &lt;code&gt;muscle class&lt;/code&gt; is going to do for us. 
What is a “muscle” ?
What is an “exercise” ?
1. A muscle has a name 
2. A muscle has many exercises.
3. An exercise belongs to a muscle.
These can be represented here in &lt;code&gt;class Muscle&lt;/code&gt;: &lt;code&gt;attr_accessor :name, :exercises&lt;/code&gt;.&lt;br /&gt;
&lt;code&gt; class Exercise &lt;/code&gt; &lt;br /&gt;
&lt;code&gt; attr_accessor :name, :muscle &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Next we want to be able to build a muscle object by scraping it off of a website. Our goal is to find all the muscles we want to include and for each muscle, create a muscle instance. To do this we are going to need a separate &lt;code&gt;Scaper&lt;/code&gt; class, since a muscle class’s responsibility is to create instances of muscles, not scrape information. In our scraper class we are going to define a &lt;code&gt;get_page&lt;/code&gt; method and setup our &lt;code&gt;Nokogiri&lt;/code&gt; with our index url. Read more about Nokogiri and open-uri &lt;a href=&quot;http://ruby.bastardsbook.com/chapters/html-parsing/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Our scraper is going to be split into 2 parts. First we will want to scrape the index page for all the muscles that are available. Then we will want to dive deeper and scrape the exercises within those muscle pages. So our first method will just scrape the index page for all the muscle titles, get just the text from those titles and push those strings into an array. Here is the code to accomplish this: &lt;code&gt;self.get_page.css(&#39;.muscle-pagination li&#39;)[0].text,&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here we can see that we are calling the get_page method within &lt;code&gt;scrape_muscles_index&lt;/code&gt; to parse the HTML page, then retrieve the specific text from the HTML and push that string into an array. We will be doing the same thing for the exercises, but since there are a lot of exercises we need to add another process.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;self.get_page.css(&#39;.exerciseName h3 a&#39;).collect {|exercise| exercise.text.strip!}&lt;/code&gt; Here we are collecting all of the exercises listed on the page (just the text), then using the &lt;code&gt;strip!&lt;/code&gt; method to remove any trailing and leading whitespace, then push that array of strings into a separate array.&lt;/p&gt;

&lt;p&gt;Next after we gather our raw data we are going to need to create objects out of them. Let’s start with muscles. Our muscles are an array of strings. We need to take each muscle from that array and instantiate it into an object, then push that new muscle instance into a class constant called &lt;code&gt;@@all&lt;/code&gt;. this is where all of our muscles will reside so we can reference them later. Going back to instantiating objects, like we learned earlier, A muscle has many exercises, so in our &lt;code&gt;initialtize&lt;/code&gt; method we are going to set an instance variable &lt;code&gt;@exercises&lt;/code&gt; set to equal an empty array. In other words every new muscle object that gets born will have an empty “pocket” for exercises to be added to it. Then we will push &lt;code&gt;self&lt;/code&gt; into &lt;code&gt;@@all&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After our muscle objects are instantiated and pushed into that &lt;code&gt;@@all&lt;/code&gt; we are going to create make and add the exercises as objects using our scrape exercises scraper method. Let’s do this by reference each index in &lt;code&gt;@@all&lt;/code&gt; like so: &lt;code&gt;@@all[0].exercises = SCRAPED_EXERCISES[0].collect {|exercise| TrainHard::Exercise.new(exercise, @@all[0])}&lt;/code&gt;&amp;lt;/br&amp;gt;
Let’s break this code down. First we are referencing the first muscle that has been instantiated in &lt;code&gt;@@all[0]&lt;/code&gt; which happens to be Abs. Then we are calling the &lt;code&gt;.exercise =&lt;/code&gt; method created by our &lt;code&gt;attr_accessor :exercise&lt;/code&gt; and setting it equal to &lt;code&gt;SCRAPED_EXERCISES[0]&lt;/code&gt; which is reference our first array of arrays which contains a bunch of our exercises as strings. For each of those exercises we are instantiating a new exercise object and setting its name equal to the exercise and its muscle as the second argument equal to its corresponding muscle &lt;code&gt;#@@all[0]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And that’s it! The bulk of our design structure is done. We now have muscle objects that have many exercises, and exercise objects that belong to muscles. We can implement this structure within the CLI and have the user obtain real object data if we wanted to add more features down the line.&lt;/p&gt;

</content>
 </entry>
 

</feed>
