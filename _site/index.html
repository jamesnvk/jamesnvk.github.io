

<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      // james novak  
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Welcome to my blog :)</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
    

    <!--<a class="sidebar-nav-item" href="/archive/v1.0.0.zip">Download</a> 
    <a class="sidebar-nav-item" href="">GitHub project</a> -->
 
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">// james_novak</a>
            <!--<small>A Jekyll theme</small>-->
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2016/03/27/sinatra-ar-mvc-app/">
        Sinatra ActiveRecord MVC Application
      </a>
    </h1>

    <span class="post-date">27 Mar 2016</span>

    <p>I’ve learned a ton since I built my first CLI gem in my last project. Flatiron School’s Full Stack Dev curriculum really knows how to keep us just on the edge of our knowledge - Always challenging and I’m absolutely addicted. This project’s requirements are as follows:</p>

<h2 id="requirements">REQUIREMENTS</h2>
<ul>
  <li>Build an MVC Sinatra Application.</li>
  <li>Use ActiveRecord with Sinatra.</li>
  <li>Use Multiple Models.</li>
  <li>Use at least one has_many relationship</li>
  <li>Must have user accounts. The user that created the content should be the only person who can modify that content</li>
  <li>Models must have validations to ensure that bad data isn’t created</li>
  <li>Any validation failures must be shown to user with an error message</li>
</ul>

<p>I decided I wanted to build a game collection app that keeps track of a users games. When I was younger (the days before Steam was a thing) I had a ton of games on PC/DVD, SNES, N64 and no where to keep track of them! My first task is to determine file structure, more importantly.. which gems I will be needing to create this app. <img src="/assets/ss1.png" alt="Alt text" /></p>

<p>Next let’s build out the models. A User <code>has many</code> games and a Game <code>belongs to</code> a user. We’re being taught that starting out with the models first is a great pattern for building web apps from scratch. This way we can directly interact with our data first before committing to building out the larger portion of the framework like the controllers and routing. We can always come back to add attributes or functionality to the models in the future as well.</p>

<p>Now let’s setup our database. We have to create 2 tables, one for users and one for games. We’re going to run <code>rake db:create_migration NAME=create_users</code> and do the same for games. Our code in our migration file will look like this: <img src="/assets/ss2.png" alt="Alt text" /></p>

<p>We’re creating 3 columns for our 3 attributes: Games have a name, year, and a foreign key: <code>user_id</code> since games <code>belong_to</code> a User. We’ll do the same for Users then run <code>rake db:migrate</code> to execute the changes. After our tables are setup we’ll need to add our 2 models to our app. <img src="/assets/ss3.png" alt="Alt text" /></p>

<p>With our tables and models setup and migrated our Users and Games are now associated. Remember that the model that has belongs_to will always have the foreign key. In this case, our Game model has the foreign key <code>user_id</code>.</p>

<p>Let’s start with the User class. We’re <code>include</code>ing instance method <code>slug</code> that will take a user’s username, downcase it, and replace all spaces with dashes. That’s the beauty of ruby.. we can just look at the method and know exactly what it does. The purpose of this method is to have our URLs remain RESTful. Next we’re <code>extend</code>ing our class method <code>find_by_slug</code> that will give us the ability to find a user by their slugified name.</p>

<p><code>has_secure_password</code> is a macro given to us by ActiveRecord. However in order to use this we will need to have <code>sessions</code> enabled and also our gem <code>bcrypt</code> that we installed earlier. <code>Bcrypt</code> gives us the ability to store a salted and hashed version of a user’s password in a database column called <code>password_digest</code>. Let’s add that now.  <img src="/assets/ss4.png" alt="Alt text" /></p>

<p>To wrap up user auth we are given a method <code>authenticate</code> that is provided to us by the Bcrypt gem, which takes a string as an argument. If the string password matches the string password in the password digest, it will return the user object, otherwise it will return false. <img src="/assets/ss5.png" alt="Alt text" /></p>

<p>We ensure that bad data isn’t being passed with our helper methods <code>logged_in?</code> which evaluates the truthiness of a session[:id] and <code>empty_field?</code> which ensures that a user fills out all form fields when logging in or signing up. Since the our session hash persists across our URLs, it is a very useful tool allowing a web app to persist a user across the entire scope of the application. In other words, the user does not have to log in every time they request a new page. This introduces “state” in an otherwise stateless web. Check out all of my controller routes and actions on my full <a href="https://github.com/jamesnvk/game-collection-sinatra-app">github repo</a>.</p>

<p>For our last requirement I decided to use the flash gem found <a href="https://github.com/SFEley/sinatra-flash">here</a>. This cool little gem adds an error message for the user when they fail a validation.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I learned a ton about how the web operates doing this project. It was a lot of work and I’m glad that I’m learning a basically smaller version of Rails before moving onto the behemoth. Feel free to send me an email jamesnovak90@gmail.com I’d love to hear from you!</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2016/01/27/jamesnovak-cli-gem/">
        Building a CLI Gem
      </a>
    </h1>

    <span class="post-date">27 Jan 2016</span>

    <div class="message">
  My first Ruby CLI Gem: Train Hard
</div>

<p>My idea for this gem is fairly straightforward. It is a command line interface that scrapes from a website that lists exercises by muscle groups. Each muscle has many exercises. Each exercise belongs to a muscle.</p>

<p>The first order of business is to bust out the notepad and organize the project into small bite sized pieces. Here’s what I got (shoutout to Avi ;))</p>

<ol>
  <li>Plan your gem, imagine your interface</li>
  <li>Start with the project structure - google</li>
  <li>Start with the entry point  - the file run</li>
  <li>Stub out the interface</li>
  <li>Start making things real. Discover objects. PROGRAM.</li>
</ol>

<p>Alright! Lets get started shall we?</p>

<h2 id="plan-your-gem-imagine-your-interface">1. Plan your gem, imagine your interface</h2>

<p>A CLI seems like a fairly simple idea. The program asks a user a question, and the user responds to the question with the correct input. So when we first run our gem we want to ask our user an important question (one which they want to be asked since they installed the gem, and one that is concise and to the point.)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Which muscle group are you training today?
</code></pre>
</div>

<p>Using <code>gets.strip</code> we can determine by number, which muscle group a user wants to see exercises for, then display that list to the user. We will of course list those muscle groups by number.</p>

<h2 id="start-with-the-project-structure">2. Start with the project structure</h2>

<p><code>bundle gem train_hard</code></p>

<p>Magic! We now have a brand new directory with all of our necessary files to create a gem.</p>

<h2 id="start-with-the-entry-point">3. Start with the entry point</h2>

<p>In our <code>bin</code> directory is where we want to encapsulate all of our code into a simple call to execute our program. It seems to be best practice not to place logic in this directory. I added <code>#!/usr/bin/env ruby</code> to tell the interpreter that this is a ruby file. I also added <code>require './lib/train_hard'</code> since we will be needing our <code>cli.rb</code> class to run the file.</p>

<p>In our <code>lib</code> directory is where the meat of the program lies. We have a file called <code>train_hard.rb</code> that is responsible for loading all the required files including our <code>nokogiri</code> gem and <code>open-uri</code>.</p>

<h2 id="stub-out-the-interface">4. Stub out the interface</h2>

<p>Our program should start just by running <code>./bin/train_hard</code> command. Inside our bin/train_hard file we should only have code that looks like this to encapsulate our logic and run our program</p>
<div class="message">
#!/usr/bin/env ruby<br />

require "bundler/setup"<br />
require "train_hard"<br />

TrainHard::CLI.new.start
</div>

<p>Our first method that is going to be run in our CLI is our <code>display_menu</code> method which displays a menu for the user to choose which muscle group they would like exercises for. For now, we are going to hard-code our method just to be able to have a visualization of what the program will look like before it becomes real. For example
<code>puts "Which muscle group are you training today? (enter number):"</code><br />
<code>
def display_menu<br />
  puts "Which muscle group are you training today?:"<br />
  puts &lt;&lt;-DOC<br />
  1. Chest<br />
  2. Back<br />
  3. Legs<br />
  4. Shoulders<br />
  5. Abs<br />
  6. Arms<br />
    DOC<br />
   end
 </code></p>

<p>Let’s do the same for our <code>pick</code> method, which will <code>gets</code> from a user to enter the number which they would like to train, then based on that number display that muscle’s exercises. Example:<br />
<code>
  def pick<br />
    input = nil<br />
    while input != "exit"<br />
    puts "Enter number of the muscle you would like to train or type menu to display menu:" <br />
    input = gets.strip <br />
      case input <br />
      when "1" <br />
      puts "Exercises for 1" <br />
      etc...
</code></p>

<p>Now that we have our code stubbed lets start actually programming!</p>

<h2 id="start-making-things-real-discover-objects-program">5. Start making things real. Discover objects. PROGRAM</h2>

<p>The fun part! The first thing we have to do is figure out what exactly a “muscle” consists of, and what our <code>muscle class</code> is going to do for us. 
What is a “muscle” ?
What is an “exercise” ?
1. A muscle has a name 
2. A muscle has many exercises.
3. An exercise belongs to a muscle.
These can be represented here in <code>class Muscle</code>: <code>attr_accessor :name, :exercises</code>.<br />
<code> class Exercise </code> <br />
<code> attr_accessor :name, :muscle </code></p>

<p>Next we want to be able to build a muscle object by scraping it off of a website. Our goal is to find all the muscles we want to include and for each muscle, create a muscle instance. To do this we are going to need a separate <code>Scaper</code> class, since a muscle class’s responsibility is to create instances of muscles, not scrape information. In our scraper class we are going to define a <code>get_page</code> method and setup our <code>Nokogiri</code> with our index url. Read more about Nokogiri and open-uri <a href="http://ruby.bastardsbook.com/chapters/html-parsing/">here</a></p>

<p>Our scraper is going to be split into 2 parts. First we will want to scrape the index page for all the muscles that are available. Then we will want to dive deeper and scrape the exercises within those muscle pages. So our first method will just scrape the index page for all the muscle titles, get just the text from those titles and push those strings into an array. Here is the code to accomplish this: <code>self.get_page.css('.muscle-pagination li')[0].text,</code></p>

<p>Here we can see that we are calling the get_page method within <code>scrape_muscles_index</code> to parse the HTML page, then retrieve the specific text from the HTML and push that string into an array. We will be doing the same thing for the exercises, but since there are a lot of exercises we need to add another process.<br /></p>

<p><code>self.get_page.css('.exerciseName h3 a').collect {|exercise| exercise.text.strip!}</code> Here we are collecting all of the exercises listed on the page (just the text), then using the <code>strip!</code> method to remove any trailing and leading whitespace, then push that array of strings into a separate array.</p>

<p>Next after we gather our raw data we are going to need to create objects out of them. Let’s start with muscles. Our muscles are an array of strings. We need to take each muscle from that array and instantiate it into an object, then push that new muscle instance into a class constant called <code>@@all</code>. this is where all of our muscles will reside so we can reference them later. Going back to instantiating objects, like we learned earlier, A muscle has many exercises, so in our <code>initialtize</code> method we are going to set an instance variable <code>@exercises</code> set to equal an empty array. In other words every new muscle object that gets born will have an empty “pocket” for exercises to be added to it. Then we will push <code>self</code> into <code>@@all</code>.</p>

<p>After our muscle objects are instantiated and pushed into that <code>@@all</code> we are going to create make and add the exercises as objects using our scrape exercises scraper method. Let’s do this by reference each index in <code>@@all</code> like so: <code>@@all[0].exercises = SCRAPED_EXERCISES[0].collect {|exercise| TrainHard::Exercise.new(exercise, @@all[0])}</code>&lt;/br&gt;
Let’s break this code down. First we are referencing the first muscle that has been instantiated in <code>@@all[0]</code> which happens to be Abs. Then we are calling the <code>.exercise =</code> method created by our <code>attr_accessor :exercise</code> and setting it equal to <code>SCRAPED_EXERCISES[0]</code> which is reference our first array of arrays which contains a bunch of our exercises as strings. For each of those exercises we are instantiating a new exercise object and setting its name equal to the exercise and its muscle as the second argument equal to its corresponding muscle <code>#@@all[0]</code></p>

<p>And that’s it! The bulk of our design structure is done. We now have muscle objects that have many exercises, and exercise objects that belong to muscles. We can implement this structure within the CLI and have the user obtain real object data if we wanted to add more features down the line.</p>


  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
